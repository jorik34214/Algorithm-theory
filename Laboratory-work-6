# Код алгоритму Дейкстри

import heapq

graph = {
    1: {2: 6, 3: 7, 4: 3},
    2: {1: 6, 3: 2, 4: 9, 6: 9},
    3: {1: 7, 2: 2, 6: 7, 8: 4},
    4: {1: 3, 2: 9, 5: 5},
    5: {4: 5, 6: 4, 7: 1},
    6: {2: 9, 3: 7, 5: 4, 7: 8, 8: 7},
    7: {5: 1, 6: 8, 8: 5},
    8: {3: 4, 6: 7, 7: 5}
}

# Алгоритм Дейкстри
def dijkstra(start):
    dist = {v: float('inf') for v in graph}
    pred = {v: -1 for v in graph}

    dist[start] = 0
    pq = [(0, start)]

    while pq:
        d, u = heapq.heappop(pq)

        if d > dist[u]:
            continue

        for v, w in graph[u].items():
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                pred[v] = u
                heapq.heappush(pq, (dist[v], v))

    return dist, pred


# Відновлення шляху
def restore_path(pred, end):
    path = []
    while end != -1:
        path.append(end)
        end = pred[end]
    return list(reversed(path))


# Запуск для вершини 1
start_vertex = 1
dist, pred = dijkstra(start_vertex)

# Вивід результатів
print("Алгоритм Дейкстри для графа варіанту:")
print("Початкова вершина:", start_vertex)
print()

print("Отримані найкоротші відстані (dist):")
for v in sorted(dist):
    print(f"  dist[{v}] = {dist[v]}")

print("\nПопередники вершин (pred):")
for v in sorted(pred):
    print(f"  pred[{v}] = {pred[v]}")

print("\nНайкоротші шляхи:")
for v in sorted(graph):
    path = restore_path(pred, v)
    print(f"  Шлях до {v}: {path} (довжина = {dist[v]})")

# Код алгоритму Флойда

import math

def floyd_warshall(matrix):
    n = len(matrix)
    dist = [row[:] for row in matrix]

    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    return dist

INF = math.inf

matrix = [
    [0, 3, 7, 5, 9],
    [3, 0, 4, 2, 6],
    [7, 4, 0, 4, 6],
    [5, 2, 4, 0, 4],
    [9, 6, 6, 4, 0]
]

manual_result = [
    [0, 3, 7, 5, 9],
    [3, 0, 4, 2, 6],
    [7, 4, 0, 4, 6],
    [5, 2, 4, 0, 4],
    [9, 6, 6, 4, 0]
]

auto_result = floyd_warshall(matrix)

print("Автоматично обчислена матриця:")
for row in auto_result:
    print(row)

print("\nРучна матриця:")
for row in manual_result:
    print(row)

same = (auto_result == manual_result)
print("\nСпівпадають:", "ТАК" if same else "НІ")
