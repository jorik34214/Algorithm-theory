# Код алгоритму Пріма  

import heapq

def prim(graph, start=0):
    n = len(graph)
    visited = [False] * n
    mst = []
    min_heap = []

    # Додаємо всі ребра з початкової вершини
    visited[start] = True
    for v, w in graph[start]:
        heapq.heappush(min_heap, (w, start, v))

    while min_heap and len(mst) < n - 1:
        w, u, v = heapq.heappop(min_heap)

        if visited[v]:
            continue

        # Додаємо ребро в MST
        visited[v] = True
        mst.append((u, v, w))

        # Додаємо всі ребра, що виходять із нової вершини
        for to, weight in graph[v]:
            if not visited[to]:
                heapq.heappush(min_heap, (weight, v, to))

    return mst

graph = {
    0: [(1, 6)],
    1: [(0, 6), (2, 3), (3, 3)],
    2: [(1, 3), (5, 1)],
    3: [(1, 3), (7, 5)],
    4: [(7, 5), (6, 5)],
    5: [(2, 1), (6, 4)],
    6: [(5, 4), (4, 5), (7, 4)],
    7: [(3, 5), (4, 5), (6, 4)]
}

# конвертуємо у формат списку суміжності
graph_list = [[] for _ in range(len(graph))]
for u in graph:
    for v, w in graph[u]:
        graph_list[u].append((v, w))

mst = prim(graph_list, start=0)

print("Мінімальне кістякове дерево (MST):")
for u, v, w in mst:
    print(f"{u} — {v} (вага {w})")

# Код алгоритму Крускала 

class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a, b):
        rootA = self.find(a)
        rootB = self.find(b)

        if rootA != rootB:
            if self.rank[rootA] < self.rank[rootB]:
                self.parent[rootA] = rootB
            elif self.rank[rootA] > self.rank[rootB]:
                self.parent[rootB] = rootA
            else:
                self.parent[rootB] = rootA
                self.rank[rootA] += 1
            return True
        return False


def kruskal(n, edges):
    # Сортуємо ребра за вагою
    edges.sort()

    dsu = DisjointSet(n)
    mst = []  # список ребер МКД
    total_weight = 0

    for w, u, v in edges:
        if dsu.union(u, v):
            mst.append((u, v, w))
            total_weight += w

    return mst, total_weight



edges = [
    (1, 4, 6),
    (2, 1, 2),
    (3, 0, 3),
    (4, 2, 7),
    (4, 4, 5),
    (5, 3, 4),
    (5, 6, 7),
    (6, 0, 1),
    (7, 0, 2),
    (7, 2, 5),
    (7, 2, 7),
    (8, 5, 6),
    (9, 1, 3),
    (9, 1, 5)
]

mst, total = kruskal(8, edges)

print("Мінімальне кістякове дерево (МКД):")
for u, v, w in mst:
    print(f"{u + 1} — {v + 1} = {w}")

print("Сумарна вага МКД =", total)
